// @generated
// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SingleIndex {
    #[prost(enumeration="SectionType", optional, tag="1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag="2")]
    pub position: ::core::option::Option<u64>,
    #[prost(oneof="single_index::Cache", tags="101, 102, 103")]
    pub cache: ::core::option::Option<single_index::Cache>,
}
/// Nested message and enum types in `SingleIndex`.
pub mod single_index {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Cache {
        #[prost(message, tag="101")]
        ChannelCache(super::ChannelCache),
        #[prost(message, tag="102")]
        ChunkHeaderCache(super::ChunkHeaderCache),
        #[prost(message, tag="103")]
        ChunkBodyCache(super::ChunkBodyCache),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChunkHeaderCache {
    #[prost(uint64, optional, tag="1")]
    pub message_number: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="2")]
    pub begin_time: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="3")]
    pub end_time: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="4")]
    pub raw_size: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChunkBodyCache {
    #[prost(uint64, optional, tag="1")]
    pub message_number: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelCache {
    #[prost(uint64, optional, tag="1")]
    pub message_number: ::core::option::Option<u64>,
    #[prost(string, optional, tag="2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub message_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="4")]
    pub proto_desc: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SingleMessage {
    #[prost(string, optional, tag="1")]
    pub channel_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="2")]
    pub time: ::core::option::Option<u64>,
    #[prost(bytes="vec", optional, tag="3")]
    pub content: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapInfo {
    #[prost(string, optional, tag="1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VehicleInfo {
    #[prost(string, optional, tag="1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Header {
    #[prost(uint32, optional, tag="1")]
    pub major_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub minor_version: ::core::option::Option<u32>,
    #[prost(enumeration="CompressType", optional, tag="3")]
    pub compress: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag="4")]
    pub chunk_interval: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="5")]
    pub segment_interval: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="6", default="0")]
    pub index_position: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="7", default="0")]
    pub chunk_number: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="8", default="0")]
    pub channel_number: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="9", default="0")]
    pub begin_time: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="10", default="0")]
    pub end_time: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="11", default="0")]
    pub message_number: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="12", default="0")]
    pub size: ::core::option::Option<u64>,
    #[prost(bool, optional, tag="13", default="false")]
    pub is_complete: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag="14")]
    pub chunk_raw_size: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="15")]
    pub segment_raw_size: ::core::option::Option<u64>,
    #[prost(message, optional, tag="16")]
    pub map_info: ::core::option::Option<MapInfo>,
    #[prost(message, optional, tag="17")]
    pub vehicle_info: ::core::option::Option<VehicleInfo>,
    #[prost(bytes="vec", optional, tag="18")]
    pub adcos_version: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Channel {
    #[prost(string, optional, tag="1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub message_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="vec", optional, tag="3")]
    pub proto_desc: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChunkHeader {
    #[prost(uint64, optional, tag="1")]
    pub begin_time: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="2")]
    pub end_time: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="3")]
    pub message_number: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="4")]
    pub raw_size: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkBody {
    #[prost(message, repeated, tag="1")]
    pub messages: ::prost::alloc::vec::Vec<SingleMessage>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Index {
    #[prost(message, repeated, tag="1")]
    pub indexes: ::prost::alloc::vec::Vec<SingleIndex>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordInfo {
    #[prost(string, optional, tag="1", default="")]
    pub record_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, optional, tag="2")]
    pub total_time_s: ::core::option::Option<f64>,
    #[prost(double, optional, tag="3", default="0")]
    pub curr_time_s: ::core::option::Option<f64>,
    #[prost(double, optional, tag="4", default="0")]
    pub progress: ::core::option::Option<f64>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SectionType {
    SectionHeader = 0,
    SectionChunkHeader = 1,
    SectionChunkBody = 2,
    SectionIndex = 3,
    SectionChannel = 4,
}
impl SectionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SectionHeader => "SECTION_HEADER",
            Self::SectionChunkHeader => "SECTION_CHUNK_HEADER",
            Self::SectionChunkBody => "SECTION_CHUNK_BODY",
            Self::SectionIndex => "SECTION_INDEX",
            Self::SectionChannel => "SECTION_CHANNEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SECTION_HEADER" => Some(Self::SectionHeader),
            "SECTION_CHUNK_HEADER" => Some(Self::SectionChunkHeader),
            "SECTION_CHUNK_BODY" => Some(Self::SectionChunkBody),
            "SECTION_INDEX" => Some(Self::SectionIndex),
            "SECTION_CHANNEL" => Some(Self::SectionChannel),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressType {
    CompressNone = 0,
    CompressBz2 = 1,
    CompressLz4 = 2,
    CompressZstd = 3,
}
impl CompressType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CompressNone => "COMPRESS_NONE",
            Self::CompressBz2 => "COMPRESS_BZ2",
            Self::CompressLz4 => "COMPRESS_LZ4",
            Self::CompressZstd => "COMPRESS_ZSTD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPRESS_NONE" => Some(Self::CompressNone),
            "COMPRESS_BZ2" => Some(Self::CompressBz2),
            "COMPRESS_LZ4" => Some(Self::CompressLz4),
            "COMPRESS_ZSTD" => Some(Self::CompressZstd),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
